# 프로토콜이란? 

특정 역할을 하기 위한 메소드, 프로퍼티, 기타 요구사항 등의 청사진



자격증이라고 생각하면 편하다. 만일 어떤 사람이 심폐 소생술 자격증을 취득했다고 하면 그 사람은 심폐 소생술을 할 수 있는 사람이다. 

어떤 객체가 특정 프로토콜을 채택(취득)했다는 것은 특정 프로토콜 내부의 메서드(행동)들을 할 수 있다는 것을 의미한다. 또한 한 사람이 여러 자격증을 취득할 수 있듯이, 프로토콜도 다중 채택이 가능하다. 



## 프로토콜의 사용 

+ 구조체, 클래스, 열거형은 프로토콜을 채택하여 특정 기능을 실행하기 위한 프로토콜의 요구사항을 실제로 구현할 수 있다. 
+ 프로토콜은 정의를 하고 제시를 할 뿐 스스로 기능을 구현하지는 않는다. 
+ 하나의 **타입**으로 사용되기 때문에 타입이 쓰이는 모든 곳에 프로토콜을 사용할 수 있다. 
  + 함수, 메소드, init의 파라미터 타입 혹은 리턴 타입
  + 상수, 변수, 프로퍼티의 타입으로 할당 가능
  + 배열, 딕셔너리의 원소 타입
  
  ##### -------> *스위프트는 프로토콜을 "일급객체"로 취급한다.* 



## Property Requirments

프로토콜에서는 프로퍼티가 

1. 저장프로퍼티인지 연산프로퍼티인지 명시하지 않는다.
2. 그 대신, 이름과 타입 그리고 get, set 키워드를 이용해 읽기/쓰기, 읽기 여부를 명시한다. 
3. 프로퍼티는 항상 var로 선언해야 한다. 
4. 타입프로퍼티 구현 가능하다. 



프로토콜은 최소한의 요구 사항이기 때문에 어떤 곳에 채택을 하여 구현을 할 때, 

get only 프로퍼티를 get, set을 모두 충족하는 프로퍼티로 구현이 가능하다. (최소한의 요구 사항만 맞추면 되기 때문에 그 이상을 하는 것은 가능하다. 하지만 읽기/쓰기 프로퍼티에서 read-only 프로퍼티로 구현하는 것은 불가능하다.)

Read-only 프로퍼티인 경우에는 var를 let으로 변경하는 것도 가능하다.

## Method Requirements

프로토콜에서는 인스턴스 메소드와 타입 메소드를 정의할 수 있다. 하지만 메소드 파라미터의 기본값은 프로토콜 안에서 사용할 수 없다. 

+ mutating 키워드

  메소드 앞에 mutating 키워드를 붙이는 것은 구조체에만 특정 짓는 것이 아니고 구조체/클래스 모두 사용할 수 있는 메서드인데 구조체/열거형에도 사용 가능하도록 내부 저장 프로퍼티 변경 메서드를 요구하는 것이다.  

## Initializer Requirements

: 프로토콜에서는 이니셜라이저도 정의할 수 있다. 

+ 실패 가능한 이니셜라이저도 선언할 수 있다. ``` init?(), init!()```

  실패 가능한 프로토콜을 구현할 때에 구현 불가능한 이니셜라이저로 구현해도 된다. 

- 특정 프로토콜의 required 이니셜라이저를 구현하고, SuperClass의 이니셜라이저를 SubClass에 상속하는 경우 **SubClass의 이니셜라이저 앞에 required 키워드와 override 키워드를 붙여줘야 한다.**  (필수적으로 구현해야하는 최소한의 요구사항이기 때문에)

  + 예외

    구조체라면 필수 생성자라는 것이 없기 때문에 required 키워드를 안붙여도 된다. 

    클래스 앞에 final 키워드를 붙인다면 상속을 하지 않는다는 의미이기 때문에 required 키워드를 붙이지 않아도 된다. 

## Subscript Requirements

+ subscript 가능하다. 최소 읽기 서브스크립트 요구할 수 있고, 읽기/쓰기 모두 요구하는 것도 가능하다.



## Protocol is Type 

스위프트에서 프로토콜을 일급객체로 취급하기 때문에 프로토콜은 타입으로써 사용될 수 있다. 변수에 할당할 수도 있고, 함수의 파라미터, 리턴값으로도 프로토콜타입을 사용할 수 있다. 

만일, 프로토콜을 채택한 클래스의 인스턴스를 생성하고 나서, 그 인스턴스의 타입을 채택한 프로토콜로 한다면 오류가 나지 않는다. 하지만 해당 인스턴스는 프로토콜 내부 요구사항(메서드, 프로퍼티 등)만 사용할 수 있다. 



**장점**

+ 해당 프로토콜을 채택한 객체들을 하나의 데이터 묶음으로 저장 할 수 있다.
+ 함수의 파라미터/리턴타입으로 사용이 가능하다. 
+ is/as 연산자 사용이 가능하다. ---> 프로토콜 준수성 검사



## protocol SomeProtocol : AnyObject { }

AnyObject는 프로토콜이기 때문에 다른 프로토콜에서 상속 받을 수 있으며,

이 프로토콜은 클래스 전용 프로토콜이 된다. -> 구조체에서는 사용할 수 없게 됨 



## Optional Protocol

프로토콜의 요구사항을 선택적으로 채택할 수 있도록 구현하기 위해서는 

프로토콜을 Objective-C에서 읽을 수 있는 코드로 바꿔줘야 한다. 

옵셔널은 @objc에서 지원하는 기능이기 때문이고 프로퍼티 앞에 @objc 키워드를 붙여줘야 하고

해당 프로퍼티 혹은 func를 optional로 하기 위해서는 

```@objc optional var something``` 혹은  ```@objc optional func doSomething```과 

같은 형태로 만들어주어야 한다. 

다만, @objc 프로토콜을 선언한다면 클래스 전용 프로토콜이기 때문에 구조체/열거형에서는 채택할 수 없다.



## Extension Protocol

프로토콜의 익스텐션을 사용하면 메서드의 기본 구현을 할 수 있다. 이 방법을 사용하면 중복되는 코드를 줄일 수 있다. 

```swift
protocol CanRun {
    func run()
}

extension CanRun {
    func run() {
        print("나는 달릴 수 있다.")
    }
}

class Runner: CanRun {}
let runner = Runner()
runner.run()
// 나는 달릴 수 있다.

class Runner2: CanRun {
    func run() {
        print("나는 더 빨리 달릴 수 있다.")
    }
}

let runner2 = Runner2()
runner2.run()
// 나는 더 빨리 달릴 수 있다. 
```

#### 주의할 점

확장에서 기본 구현을 제공하는 메서드는 해당 프로토콜을 채택해서 필수적으로 구현하지 않아도 된다. 다만 채택한 곳 내부에서 메서드를 구현을 할 경우에는 기본 구현이 아닌 직접 구현한 것을 우선순위로 한다. 



참고

https://medium.com/@jgj455/%EC%98%A4%EB%8A%98%EC%9D%98-swift-%EC%83%81%EC%8B%9D-protocol-f18c82571dad

https://kimgaeun.tistory.com/8